<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">	
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css') }}">


    <title>State Estimator View</title>
</head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>


function redraw(){

let aspect = Math.min(window.innerWidth / img.width, window.innerHeight / img.height);

canvas.width  = img.width * aspect;
canvas.height = img.height * aspect;
ctx.drawImage(img, 0, 0,canvas.width,canvas.height);
}


var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var img = new Image();
img.src = '/static/field.png';
img.onload = (event) => {redraw();}
addEventListener("resize", (event) => {redraw();});

FIELDW = (54*12+1)*2.54;
FIELDH = (27*12+7)*2.54;

function scale(d) {//CM TO pix
return d * canvas.width/FIELDW;
}

function toxpix(x) {//CM TO pix
return scale(x + FIELDW/2);
}
function toypix(y) {//CM TO pix
return scale(FIELDH/2 - y);
}



//https://stackoverflow.com/a/17126036/933173
function drawRotatedRect(ctx, x,y,width,height,degrees, color){

        // first save the untranslated/unrotated context
        ctx.save();

        ctx.beginPath();
        // move the rotation point to the center of the rect
        ctx.translate( x+width/2, y+height/2 );
        // rotate the rect
        ctx.rotate(degrees*Math.PI/180);

        // draw the rect on the transformed context
        // Note: after transforming [0,0] is visually [x,y]
        //       so the rect needs to be offset accordingly when drawn
        ctx.rect( -width/2, -height/2, width,height);

        ctx.fillStyle=color;
        ctx.fill();

        // restore the context to its untranslated/unrotated state
        ctx.restore();

    }



function canvas_arrow(context, fromx, fromy, tox, toy) {
  var headlen = 10; // length of head in pixels
context.beginPath();
  var dx = tox - fromx;
  var dy = toy - fromy;
  var angle = Math.atan2(dy, dx);
  context.moveTo(fromx, fromy);
  context.lineTo(tox, toy);
  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
  context.moveTo(tox, toy);
  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
context.stroke();
}



function drawRobot(state){

    function robot_arrow(fromx, fromy, tox, toy) {
        d1 = Math.sqrt(fromx**2+fromy**2);
        a1 = state.theta * Math.PI/180 + Math.atan2(fromy, fromx);
        d2 = Math.sqrt(tox**2+toy**2);
        a2 = state.theta * Math.PI/180 + Math.atan2(toy, tox);
        canvas_arrow(ctx, toxpix(state.x+d1*Math.cos(a1)), toypix(state.y+d1*Math.sin(a1)),
            toxpix(state.x+d2*Math.cos(a2)), toypix(state.y+d2*Math.sin(a2)));
    }


    drawRotatedRect(ctx, toxpix(state.x-40*2.54/2), toypix(state.y+31*2.54/2), scale(40*2.54), scale(31*2.54),-state.theta, "blue");
    drawRotatedRect(ctx, toxpix(state.x       -34*2.54/2), toypix(state.y       +25*2.54/2), scale(34*2.54), scale(25*2.54),-state.theta, "silver");
ctx.fillStyle="red";
    robot_arrow(30,0,40,0);
//    robot_arrow(0,0,state.vx,state.vy);
    ctx.save();
    ctx.lineWidth = 5;
    canvas_arrow(ctx, toxpix(state.x), toypix(state.y),
        toxpix(state.x+state.vx), toypix(state.y+state.vy));
    ctx.restore();
//    canvas_arrow(ctx, toxpix(x), toypix(y),
//        toxpix(x+30*Math.cos(r*Math.PI/180)), toypix(y+30*Math.sin(r*Math.PI/180)));
//drawArrowhead(ctx, {'x':x, 'y':y}, {'x':x+scale(300)*Math.cos(r*Math.PI/180), 'y':y+scale(300)*Math.cos(r*Math.PI/180)}, 3);
}

async function getState(){
const r = await fetch('/stateest');
const state = await r.json();
console.log(state);
ctx.drawImage(img, 0, 0,canvas.width,canvas.height);
drawRobot(state);
}
setInterval(getState, 200);

</script>
    </body>
</html>
