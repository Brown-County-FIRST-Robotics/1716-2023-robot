<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">	
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css') }}">


    <title>State Estimator View</title>
</head>
<body>
<canvas id="myCanvas" width="100%" height="100%"></canvas>
<script>


function redraw(){

let aspect = Math.min(window.innerWidth / img.width, window.innerHeight / img.height);

canvas.width  = img.width * aspect;
canvas.height = img.height * aspect;
ctx.drawImage(img, 0, 0,canvas.width,canvas.height);
}


var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var img = new Image();
img.src = '/static/field.png';
img.onload = (event) => {redraw();}
addEventListener("resize", (event) => {redraw();});

FIELDW = (54*12+1)*2.54;
FIELDH = (27*12+7)*2.54;

function scale(d) {//CM TO pix
return d * canvas.width/FIELDW;
}

function toxpix(x) {//CM TO pix
return scale(x + FIELDW/2);
}
function toypix(y) {//CM TO pix
return scale(y + FIELDH/2);
}



//https://stackoverflow.com/a/17126036/933173
function drawRotatedRect(ctx, x,y,width,height,degrees, color){

        // first save the untranslated/unrotated context
        ctx.save();

        ctx.beginPath();
        // move the rotation point to the center of the rect
        ctx.translate( x+width/2, y+height/2 );
        // rotate the rect
        ctx.rotate(degrees*Math.PI/180);

        // draw the rect on the transformed context
        // Note: after transforming [0,0] is visually [x,y]
        //       so the rect needs to be offset accordingly when drawn
        ctx.rect( -width/2, -height/2, width,height);

        ctx.fillStyle=color;
        ctx.fill();

        // restore the context to its untranslated/unrotated state
        ctx.restore();

    }

canvas_arrow(ctx, 10, 30, 200, 150);


function canvas_arrow(context, fromx, fromy, tox, toy) {
  var headlen = 10; // length of head in pixels
context.beginPath();
  var dx = tox - fromx;
  var dy = toy - fromy;
  var angle = Math.atan2(dy, dx);
  context.moveTo(fromx, fromy);
  context.lineTo(tox, toy);
  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
  context.moveTo(tox, toy);
  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
context.stroke();
}


function drawRobot(x, y, r){
drawRotatedRect(ctx, toxpix(x-3*2.54-40*2.54/2), toypix(y-3*2.54-31*2.54/2), scale(40*2.54), scale(31*2.54),r, "blue");
drawRotatedRect(ctx, toxpix(x       -40*2.54/2), toypix(y       -31*2.54/2), scale(34*2.54), scale(25*2.54),r, "silver");
ctx.fillStyle="red";
canvas_arrow(ctx, toxpix(x-3*2.54-40*2.54/2), toypix(y-3*2.54-31*2.54/2),
toxpix(x-3*2.54-40*2.54/2+30), toypix(y-3*2.54-31*2.54/2+30));
//drawArrowhead(ctx, {'x':x, 'y':y}, {'x':x+scale(300)*Math.cos(r*Math.PI/180), 'y':y+scale(300)*Math.cos(r*Math.PI/180)}, 3);
}

async function getState(){
const r = await fetch('/stateest');
const state = await r.json();
console.log(state);
ctx.drawImage(img, 0, 0,canvas.width,canvas.height);
drawRobot(state.x,state.y,state.theta);
}
setInterval(getState, 200);

</script>
    </body>
</html>
